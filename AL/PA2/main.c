#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#define MAX_SIZE 10000

char *src_1[MAX_SIZE];
char *src_2[MAX_SIZE];
char buf[MAX_SIZE];
char *lcs[MAX_SIZE];
char *var_list[MAX_SIZE];

int len_lcs;
int var_list_idx;
float hit_ratio;

int read_file(FILE *fp, char **src);
void tokenize(char **src, int len);
void LCS(char **src_1, int m, char **src_2, int n);
void print_file(FILE *fp, int len1, int len2);

void main(int argc, char **argv)
{
    if (argc != 3)
    {
        printf("Failed to open file");
        exit(1);
    }

    char *path1 = argv[1];
    char *path2 = argv[2];
    char *path3 = "hw2_output.txt";

    FILE *fp1, *fp2, *fp3;

    if ((fp1 = fopen(path1, "r")) == NULL)
    {
        printf("Failed to open file");
        exit(1);
    }
    if ((fp2 = fopen(path2, "r")) == NULL)
    {
        printf("Failed to open file");
        exit(1);
    }
    if ((fp3 = fopen(path3, "w")) == NULL)
    {
        printf("Failed to open file");
        exit(1);
    }

    int len1 = read_file(fp1, src_1);
    int len2 = read_file(fp2, src_2);
    tokenize(src_1, len1);
    tokenize(src_2, len2);
    LCS(src_1, len1, src_2, len2);
    int short_len = (len1 < len2) ? len1 : len2;
    hit_ratio = (float)len_lcs / short_len;

    print_file(fp3, len1, len2);

    fclose(fp1);
    fclose(fp2);
    fclose(fp3);
}

int read_file(FILE *fp, char **src)
{
    int count = 0;
    int buf_len = 0;
    int comment_pos = -1;
    int len = 0;

    for (int i = 0; !feof(fp); i++)
    {
        fgets(buf, MAX_SIZE, fp);
        buf_len = strlen(buf);
        if (buf[buf_len - 1] == '\n') // remove \n generated by fgets function
        {
            buf[buf_len - 1] = '\0';
        }

        if (buf[buf_len - 3] == '/' && buf[buf_len - 2] == '*') // remove comments with /* */
        {
            while (buf[buf_len - 3] != '*' && buf[buf_len - 2] != '/')
            {
                fgets(buf, MAX_SIZE, fp);
            }
            fgets(buf, MAX_SIZE, fp);
            buf_len = strlen(buf);
            if (buf[buf_len - 1] == '\n')
            {
                buf[buf_len - 1] = '\0';
            }
        }

        for (int i = 0; i < buf_len; i++) // remove comments with //
        {
            if (buf[i] == '/' && buf[i + 1] == '/')
            {
                comment_pos = i;
                break;
            }
        }
        if (comment_pos != -1)
        {
            buf[comment_pos] = '\0';
        }
        comment_pos = -1;
        i = 0;

        for (int i = 0; i < buf_len; i++) // remove parentheses, braces(or curly brackets), brackets, commas, and semicolons
        {
            if (buf[i] == '(' || buf[i] == ')' || buf[i] == '{' || buf[i] == '}' || buf[i] == ']' || buf[i] == ',' || buf[i] == ';')
            {
                buf[i] = ' ';
            }
        }

        char *token = strtok(buf, " \t\n"); // split the string by whitespace characters

        if (token != NULL)
        {
            src[count++] = strdup(token);
        }

        while (token != NULL)
        {
            token = strtok(NULL, " \t\n");

            if (token != NULL) // to deal with definition array
            {
                if (strstr(token, "[") != NULL)
                {
                    token = strtok(token, "[");
                    src[count++] = strdup(token);
                    var_list[var_list_idx++] = strdup(token);
                }
                else
                {
                    src[count++] = strdup(token);
                }
            }
        }
    }
    for (int i = 0; i < MAX_SIZE; i++)
    {
        if (src[i] != NULL)
        {
            len++;
        }
    }

    return len;
}

void tokenize(char **src, int len)
{
    int func_pos = -1;

    for (int i = 0; i < len; i++)
    {
        if (src[i] != NULL)
        {
            if (strstr(src[i], "\"") != NULL) // replace string with "STR_LITERAL"
            {
                src[i] = strdup("STR_LITERAL");
            }
            else if (src[i][0] == '0' || src[i][0] == '1' || src[i][0] == '2' || src[i][0] == '3' || src[i][0] == '4' ||
                     src[i][0] == '5' || src[i][0] == '6' || src[i][0] == '7' || src[i][0] == '8' || src[i][0] == '9') // replace numerical with "NUM_LITERAL"
            {
                src[i] = strdup("NUM_LITERAL");
            }
            else if (strstr(src[i], "=") != NULL) // replace variable name with "VAR"
            {
                var_list[var_list_idx++] = strdup(src[i - 1]);
                src[i - 1] = strdup("VAR");
            }
            else
            {
                for (int j = 0; j < MAX_SIZE; j++) // replace variable name with "VAR"
                {
                    if (var_list[j] != NULL)
                    {
                        if (strstr(var_list[j], src[i]) != NULL)
                        {
                            src[i] = strdup("VAR");
                        }
                    }
                }
            }
        }
    }

    for (int i = 0; i < len; i++)
    {
        if (src[i] != NULL)
        {
            if (strstr(src[i], "#include") == NULL && strstr(src[i], "<stdio.h>") == NULL && strstr(src[i], "<stdlib.h>") == NULL &&
                strstr(src[i], "#define") == NULL && strstr(src[i], "void") == NULL && strstr(src[i], "return") == NULL &&
                strstr(src[i], "short") == NULL && strstr(src[i], "int") == NULL && strstr(src[i], "unsigned") == NULL &&
                strstr(src[i], "long") == NULL && strstr(src[i], "char") == NULL && strstr(src[i], "float") == NULL &&
                strstr(src[i], "double") == NULL && strstr(src[i], "struct") == NULL && strstr(src[i], "typedef") == NULL &&
                strstr(src[i], "union") == NULL && strstr(src[i], "enum") == NULL && strstr(src[i], "+") == NULL &&
                strstr(src[i], "-") == NULL && strstr(src[i], "*") == NULL && strstr(src[i], "/") == NULL &&
                strstr(src[i], "%") == NULL && strstr(src[i], "=") == NULL && strstr(src[i], ">") == NULL &&
                strstr(src[i], "<") == NULL && strstr(src[i], "!") == NULL && strstr(src[i], "&") == NULL &&
                strstr(src[i], "|") == NULL && strstr(src[i], "^") == NULL && strstr(src[i], "~") == NULL &&
                strstr(src[i], "printf") == NULL && strstr(src[i], "scanf") == NULL &&
                strstr(src[i], "if") == NULL && strstr(src[i], "else") == NULL &&
                strstr(src[i], "while") == NULL && strstr(src[i], "for") == NULL && strstr(src[i], "break") == NULL &&
                strstr(src[i], "STR_LITERAL") == NULL && strstr(src[i], "NUM_LITERAL") == NULL && strstr(src[i], "VAR") == NULL &&
                strstr(src[i], "FUNC") == NULL)
            {
                src[i] = strdup("FUNC");
            }
        }
    }
}

void LCS(char **src_1, int m, char **src_2, int n)
{
    int len;
    int C[m + 1][n + 1];

    for (int i = 0; i <= m; i++)
    {
        for (int j = 0; j <= n; j++)
        {
            if (i == 0 || j == 0)
            {
                C[i][j] = 0;
            }
            else if (strcmp(src_1[i - 1], src_2[j - 1]) == 0)
            {
                C[i][j] = C[i - 1][j - 1] + 1;
            }
            else
            {
                C[i][j] = (C[i][j - 1] > C[i - 1][j]) ? C[i][j - 1] : C[i - 1][j];
            }
        }
    }

    int i = m;
    int j = n;

    while (i > 0 && j > 0)
    {
        if (strcmp(src_1[i - 1], src_2[j - 1]) == 0)
        {
            lcs[len_lcs] = src_1[i - 1];
            i--;
            j--;
            len_lcs++;
        }
        else if (C[i - 1][j] > C[i][j - 1])
        {
            i--;
        }
        else
        {
            j--;
        }
    }
}

void print_file(FILE *fp, int len1, int len2)
{
    for (int i = 0; i < len1; i++)
    {
        if (src_1[i] != NULL)
        {
            fprintf(fp, "%s\n", src_1[i]);
        }
    }
    fprintf(fp, "*****\n");
    for (int i = 0; i < len2; i++)
    {
        if (src_2[i] != NULL)
        {
            fprintf(fp, "%s\n", src_2[i]);
        }
    }
    fprintf(fp, "*****\n");
    for (int i = len_lcs - 1; i >= 0; i--)
    {
        fprintf(fp, "%s\n", lcs[i]);
    }
    fprintf(fp, "*****\n");
    fprintf(fp, "%.2f", hit_ratio * 100);
}